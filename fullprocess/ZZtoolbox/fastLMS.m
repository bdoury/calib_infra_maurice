function [Wf,e, wt]=fastLMS(alpha,u,d,gamma,winit)%FASTLMS% Call:%           [Wf,e, wt] = fastlms(alpha,M,u,d,gamma,P);%% Adaptive Signal Processing 2010 Computer Exercise 4%%% Input arguments:% alpha =step size, dim 1x1% M =filter length, dim 1x1% u =input signal, dim Nx1% d =desired signal, dim Nx1% gamma =forgetting factor, dim 1x1% P =initial value, energy, dim 2Mx1M = length(winit);W0 = fft(winit,2*M);P  = ones(2*M,1);%pwelch(u,[],[],2*M,'twosided');W=W0;% Output arguments:% e =estimation error, dim Nx1% w =final filter vector, dim Mx1% The length N must be chosen such that N/M is integer!% initializationN=length(u);% make sure that d and u are column vectorsd=d(:);u=u(:);e=d;% no.of blocksBlocks=N/M;% loop, FastLMSfor k=1:Blocks-1    % block k-1, k; transformed input signal U(k) (Eq.10.25)    Uvec=fft(u((k-1)*M+1:(k+1)*M),2*M);        % block k, output signal y(k), last M elements (Eq.10.26)    yvec=ifft(Uvec.*W);    yvec=yvec(M+1:2*M,1);    % block k; desired signal (Eq.10.27)    dvec=d(k*M+1:(k+1)*M);    % Adaptive Signal Processing 2010    % Computer Exercise 4    % block k, error signal (Eq.10.28)    e(k*M+1:(k+1)*M,1)=dvec-yvec;    % transformation of estimation error (Eq.10.29)    Evec=fft([zeros(M,1);e(k*M+1:(k+1)*M)],2*M);    % estimated power (Eq.10.35)    P=gamma*P+(1-gamma)*abs(Uvec).^2;    % block k, inverse of power (Eq.10.37)    Dvec=1./P;        % estimated gradient (Eq.10.39)    phivec=ifft(Dvec.*conj(Uvec).*Evec,2*M);    phivec=phivec(1:M);    % update of weights    W=W+alpha*fft([phivec;zeros(M,1)],2*M);end% The error vector should have only real values.% Therefore, extract the real part!e=real(e(:));% transform of final weights to time domain.%% make sure that w is real-valuedwt=ifft(W);wt=real(wt(1:M));Wf=fft(wt);